<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>flashed cards</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script>
    "use strict";

    class Flashcard {
      id; front; back;

      constructor(props) {
        Object.assign(this, props);
      }

      cryo() {
        return `new Flashcard(${JSON.stringify(this)})`;
      }
    }

    class CardDeck {
      id; cards;

      cardsById;

      constructor(props) {
        Object.assign(this, props);

        this.cardsById = {};
        for (let card of this.cards) {
          this.cardsById[card.id] = card;
        }
      }

      cryo() {
        return `new CardDeck({id:"${this.id}",cards:[${this.cards.map(card => card.cryo()).join(",")}]})`;
      }
    }

    class Database {
      decks; decksById;

      constructor(props) {
        Object.assign(this, props);
        console.log(this);

        this.decksById = {};
        for (let deck of this.decks) {
          this.decksById[deck.id] = deck;
        }
      }
      
      addDeck(deck) {
        this.decks.push(deck);
        this.decksById[deck.id] = deck;
        dirty();
      }

      cryo() {
        return `new Database({decks:[${this.decks.map(deck => deck.cryo()).join(",")}]})`;
      }
    }

  </script>
  <script id="globals">
    "use strict";
    globalThis.generation = 0;
    globalThis.database = new Database({ decks: [new CardDeck({ id: "deck", cards: [new Flashcard({ id: "foo", front: "FRONT", back: "BACK" })] })] });
  </script>
  <script>
    "use strict";

    function $(sel) {
      let result = document.querySelectorAll(sel);
      if (sel[0] == '#' && result.length == 1) return result[0]; //act more like getElementById
      else return result; //else return all the elements
    }

    function clear(sel) {
      document.querySelectorAll(sel).forEach(elem => {
        while (elem.firstChild) elem.firstChild.remove();
      });
    }

    //from "facon" by terkelg (some contributions by me)
    // https://github.com/terkelg/facon/
    // MIT license
    function h(strings, ...args) {
      const template = document.createElement(`template`);
      template.innerHTML = args.reduce((prev, value, i) =>
        prev + ((value instanceof HTMLElement || value instanceof DocumentFragment) ? `<b append=${i}></b>` : value) + strings[i + 1],
        strings[0]
      );

      const content = template.content;
      content.querySelectorAll(`[append]`).forEach(refNode => {
        refNode.parentNode.insertBefore(args[refNode.getAttribute('append')], refNode);
        refNode.parentNode.removeChild(refNode);
      });

      content.collect = ({ attr = 'ref', keepAttribute, to = {} } = {}) => {
        const refElements = content.querySelectorAll(`[${attr}]`);
        return [...refElements].reduce((acc, element) => {
          const propName = element.getAttribute(attr).trim();
          !keepAttribute && element.removeAttribute(attr);
          acc[propName] = acc[propName]
            ? Array.isArray(acc[propName])
              ? [...acc[propName], element]
              : [acc[propName], element]
            : element;
          return acc;
        }, to);
      };

      return content;
    }

    let currentScreen = undefined;

    function openScreen(screen) {
      if (currentScreen && currentScreen.deinit) currentScreen.deinit();

      currentScreen = screen;

      let items = screen.init();

      clear("#screen");
      if (!Array.isArray(items)) items = [items];
      for (let item of items) $("#screen").appendChild(item);
    }

    class SelectDeckScreen {
      constructor() { }

      init() {
        let left;
        if (globalThis.database.decks.length > 0) {
          left = h`<div>
            <p>Pick a deck to study:</p>
            <ul class="decklist" ref="list"></ul>
          </div>`;

          let { list } = left.collect();

          for (let deck of globalThis.database.decks) {
            let li = h`<li><a ref="a">${deck.id}</a></li>`;
            let { a } = li.collect();
            a.addEventListener("click", e => openScreen(new StudyScreen(deck)));
            list.appendChild(li);
          }
        } else {
          left = h`<div><p>No decks.</p></div>`
        }

        let hmm = h`<div class="select-deck">
          ${left}
          <div>
            <p>This is miniflash. You have ${globalThis.database.decks.length} deck${globalThis.database.decks.length == 1 ? "" : "s"}.</p>
            <button ref="addNew">Add a new deck</button>
          </div>
        </div>`;

        let { addNew } = hmm.collect();
        addNew.addEventListener("click", e => openScreen(new AddDeckScreen()));
        return hmm;
      }
    }

    class AddDeckScreen {
      constructor() { }

      init() {
        let hmm = h`<div class="add-deck">
          <div>Name of deck:</div>
          <input ref="textbox" type="text" autofocus />
          <button ref="add">Add deck</button>
        </div>`

        let { textbox, add } = hmm.collect();

        //come up with a fresh default name for the deck
        let newName = "";
        let i = 1;
        do {
          newName = "Deck " + i;
          i++;
        } while (globalThis.database.decksById[newName]);
        textbox.value = newName;

        add.addEventListener("click", e => {
          let deckName = textbox.value;
          let deck = new CardDeck({id: deckName, cards: []});
          globalThis.database.addDeck(deck);
          
          openScreen(new SelectDeckScreen());
        });

        return hmm;
      }
    }
    
    class StudyScreen {
      deck;

      toStudy;
      correct;
      incorrect;

      currentCard;
      currentSide;

      //html elements and other errata
      cardElement;
      anotherButton;
      keypressListener;

      constructor(deck) {
        console.log(deck);
        this.deck = deck;

        this.toStudy = [];
        this.correct = [];
        this.incorrect = [];

        this.currentCard = undefined;
        this.currentSide = "front";
      }

      init() {
        let elements = h`<div id="study">
          <div ref="card" id="flashcard"></div>
          <button ref="another" id="another"><u>a</u>nother</button>
        </div>`

        let { card, another } = elements.collect();
        this.cardElement = card;
        this.anotherButton = another;

        card.addEventListener("click", () => this.flip());
        another.addEventListener("click", (e) => {
          this.another();
          e.target.blur(); //so pressing space doesnt press the button again
        });

        //disable double-click-to-select on the card
        card.addEventListener("mousedown", e => {
          if (e.detail > 1) e.preventDefault();
        });

        //hotkeys
        document.addEventListener("keypress", this.keypressListener = e => {
          if (e.key == "a") {
            this.another();
            e.preventDefault();
          } else if (e.key == " ") {
            this.flip();
            e.preventDefault();
          }
        });

        //initial card draw
        this.another();

        return elements;
      }

      deinit() {
        document.removeEventListener("keypress", this.keypressListener);
      }

      another() {
        if (this.toStudy.length == 0) this.reshuffle();

        this.currentCard = this.toStudy[this.toStudy.length - 1];
        this.display();
        this.toStudy.pop();
      }

      reshuffle() {
        this.toStudy = Object.keys(this.deck.cardsById);
        for (let i = this.toStudy.length - 1; i > 0; i--) {
          let j = Math.floor(Math.random() * (i + 1));
          [this.toStudy[i], this.toStudy[j]] = [this.toStudy[j], this.toStudy[i]];
        }
        console.log("shuffled! ", this.toStudy);
      }

      display() {
        let card = this.deck.cardsById[this.currentCard];
        this.cardElement.innerHTML = card[this.currentSide];
        this.cardElement.style.backgroundColor = (this.currentSide == "front" ? "white" : "#DEDEDE"); //todo use classes
      }

      flip() {
        this.currentSide = (this.currentSide == "front" ? "back" : "front");
        this.display();
      }
    }

    function dirty() {
      $("#save").style.outline = "2px solid red";
    }
    
    function clean() {
      $("#save").style.outline = "none";
    }
    
    function quine() {
      let copy = document.documentElement.cloneNode(true);
      copy.querySelectorAll(".dynamic, .dynamic-inside *").forEach(elem => elem.remove());
      copy.querySelectorAll(".dynamic-inside").forEach(elem => {
        while (elem.firstChild) elem.firstChild.remove();
      });

      generation++;

      let globalsToSave = ["generation", "database"];
      let globalsScript = `\n"use strict";\n`;
      for (let globalName of globalsToSave) {
        let global = globalThis[globalName];
        console.log(globalName, global);
        let cryo = global.cryo ? global.cryo() : JSON.stringify(global);

        globalsScript += globalName + " = " + cryo + ";\n";
      }

      generation--; //restore
      copy.querySelector("#globals").innerHTML = globalsScript;

      let stringified = `<!DOCTYPE html>\n` + copy.outerHTML;
      
      clean();

      //download
      if (true) { // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        console.log(stringified);
        return;
      }

      let blob = new Blob([stringified], { type: "text/html" });
      let url = URL.createObjectURL(blob);
      let a = document.createElement("a");
      a.href = url;
      a.download = "quine.html";
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
    }

    document.addEventListener("DOMContentLoaded", () => {
      $("#generation").innerHTML = globalThis.generation;
      $("#save").addEventListener("click", e => quine());
      $("#title").addEventListener("click", e => openScreen(new SelectDeckScreen()));
      openScreen(new SelectDeckScreen());
    });

  </script>
  <style>
    :root {
      --white: #fff;
      --grey: #dedede;

      --pad-small: 0.5rem;
      --pad-med: 1rem;
      --pad-lg: 2rem;
    }

    a {
      cursor: pointer;
    }

    html,
    body {
      margin: 0;
      box-sizing: border-box;
      
      font-family: system-ui;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--pad-med);
    }

    nav {
      width: 100%;

      background-color: var(--grey);
      padding: var(--pad-small) var(--pad-small);
      box-sizing: border-box;

      display: flex;
      flex-direction: row;
      justify-content: space-between;
    }

    .select-deck {
      display: flex;
      flex-direction: row;
      gap: var(--pad-lg);
    }

    .select-deck>* {
      padding: var(--pad-med);
      border: 1px solid black;
      border-radius: var(--pad-small);
    }

    .decklist {
      font-size: 200%;
    }

    .decklist a {
      color: red;
    }

    .add-deck {
      display: flex;
      flex-direction: column;
      align-items: start;
      gap: var(--pad-med);
    }

    #flashcard {
      width: 35rem;
      height: 20rem;
      background-color: white;
      color: black;
      font-size: 3rem;
      border: 3px solid black;
      box-shadow: 3px 3px 0px gray;

      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
  </style>
</head>

<body>
  <nav>
    <h1><a id="title">miniflash</a></h1>
    <button id="save">save (generation <span id="generation" class="dynamic-inside"></span>)</button>
  </nav>
  <main id="screen">

  </main>
</body>

</html>